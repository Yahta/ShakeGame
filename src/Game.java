        import javax.swing.*;
        import java.awt.*;
        import java.awt.event.ActionEvent;
        import java.awt.event.ActionListener;
        import java.awt.event.KeyAdapter;
        import java.awt.event.KeyEvent;
        import java.util.Random;


public class Game extends JPanel implements ActionListener{ // (_5_) класс Game будет наследоваться от Jpanel,
    // панель на которой будут происходить действия игры.
    // implements ActionListener напишем потом, это будет (_17_) шаг
    // затем заимпортиваем его от библиотеки Swing
    // (_6_) далее экземпляр этого класса добавляем в основное окнос помощью метода add
    // далее здесь на этой вкладке создаем конструктор, т.е. открытый класс Game
    // (_17_) добавляем implements, т.е. имплементируем (реализуем) интерфейс ActionListener (действие слушателя)
    // появляется красная лампочка, выбираем Imlement methods, выбираем имплементировать метод,
    // появляется @Override
    //    public void actionPerformed (_18_) ниже
    //

    // (_10_) вот эти поля. Приват, потому что настройки игры закрыты в этом классе, пользователь не сможет их изменить

    private final int SIZE = 320; // размер поля
    private final int DOT_SIZE = 16; // размер в пикселях того, сколько пикселей
    // будет занимать одна ячейка змейки и сот-но размер яблочка
    // одно яблочко - одна секция змейки
    private final int ALL_DOTS = 400; // сколько всего единиц сможет поместиться на  игровом поле
    private Image dot; // создаем поле под игровую ячейку. Этот метод нужно заимпортировать из Библиотеки awt
    private Image apple; // по такому же принципу добавляем переменную яблока
    private int appleX; // в отдельных переменных будет храниться Х-позиция яблока
    private int appleY; // и Y-позиция яблока
    // создаем два массива чтобы хранить все положения змейки,
    // сохранять каждую секунду с какой она частотой изменяет частоту игрового поля ?
    private int[] x = new int[ALL_DOTS]; // создаем new int от ALL_DOTS создаем по максимуму
    // как если бы она занимала все поле
    private int[] y = new int[ALL_DOTS]; // то же самое для позиции Y
    private int dots; // размер змейки в данный момент времени
    private Timer timer; // задаем стандартный Swingовый таймер
    private boolean left = false; // создаем 5 буленовских полей,
    // которые будут задавать текущее направление движения змейки
    // в принципе не обязательно прописыать false (ложь),
    // поскольку все примитивные поля инициализируются начальными значениями в Java,
    // а начальное значение для булево это false
    private boolean right = true;
    private boolean up = false;
    private boolean down = false;
    private boolean inGame = true; // inGame мы еще в игре или мы уже слились
    // пишем соот-но true потому что при инициализации поля мы в игре
    // это все, что нам понадобиться, чтобы сотворить игру.
    // Далее прописываем методы, которые будут выполнять основную работу.
    // Возвращаемся к нашему конструктору тела public Game


    public Game(){ // (_8_) создаем конструктор
        // (_9_) но перед этим задаем большое количество всяких полей этого класса для определения игровых параметров. Идем наверх
        setBackground(Color.black); // (_11_) добавляем цвет игрового поля
        loadImages(); // (_13_) вот мы вызывали этот метод здесь в конструкторе
        initGame(); // (_24_) вызвать этот метод в конструкторе
        addKeyListener(new FieldKeyListener()); // (_31_) вот добавили
        setFocusable(true); // (_32_) затем нужно вызвать метод добавить фокус,
        // чтобы взаимодействие клавиш было соединено с игровым полем
        // и последнее что нужно добавить в игру табличка игра закончена (_33_)

    }

    public void initGame(){ // (_14_) создаем метод, который инициализирует начало игры
        dots = 3; // инициализируем начальное количество точек 3 штуки, начальное положение змейки
        for (int i = 0; i < dots; i++) { // через  цикл for с следующими параметрами
            x[i] = 48 - i*DOT_SIZE; // начальные значения для каждого из x-позиции
            // 48 потому что это число кратно 16(размер ячейки)
            y[i] = 48; // и y-позиции. То есть плашмя положиться вдоль оси x
        }
        timer = new Timer(250,this); // (_15_) создаем таймер 250 милисекунд,
        // т.е. с какой частотой змейка будет инициализировать свое значение, то бишь тикать.
        // this пишем,чтобы обозначить, что вот этот класс Game будет отвечать за обработку
        // каждого вызова таймера, каждые 250 милисекунд
        // спецально для этого создается отдельный метод и лимитируется в отдельный интерфейс
        timer.start(); // запускаем таймер
        createApple(); // здесь же вызываем метод для создания яблока
    }

    public void createApple(){ // (_16_) ранее  в шаге(_10_) спецально создали два поля класса
        // private int appleX и appleY.
        appleX = new Random().nextInt(20)*DOT_SIZE; // создаем новый рандом и заимпорчиваем его.
        // nextInt от 20, потому что 20 16-тиксельных квадратиков может поместиться на игровое поле,
        // соответственно 20 разных позиций по x и по y.
        // затем умножаем на размерность поля
        appleY = new Random().nextInt(20)*DOT_SIZE; // то же самое по y
    }

    public void loadImages(){ // (_12_) создаем метод для загрузки картинок
        // (_13_) далее берем картинки, просто тащим файлы и забрасываем их в сам проект, у нас SnakeGame
        ImageIcon iia = new ImageIcon("apple.png"); // используем этот метод чтобы загрузить
        // картинки в игру. Название картинки пишем в "" соотв-но названию файла
        apple = iia.getImage(); // затем проинициализируем объект типа Image
        ImageIcon iid = new ImageIcon("dot.png"); // тоже самое для дота
        dot = iid.getImage(); // если что iia iid сокращенное инициализированное название для удобства
        // по окончанию вызываем этот метод в нашем конструкторе public Game
    }

    // (_22_) нажимаем правую кнопку мыши, переходим в меню Generate, выбираем Override Methods,
    // находи метод paintComponent

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g); // (_23_) в прорисовке super происходит стандартная всего компонента,
        // т.е. вся техническая информация происходит за кулисами
        // нам нужно перерисовать, что происходит в игре
        if(inGame){ // если в игре
            g.drawImage(apple,appleX,appleY,this);
            // то рисуем яблоко (яблоко, позиция x, позиция y, кто перерисовывает)
            for (int i = 0; i < dots; i++) { // с помощью цикла for перерисовываем всю змейку
                // сколько точек, столько и перерисовываем
                g.drawImage(dot,x[i],y[i],this); // рисуется точка
            }
        } else{ // (_33_) теперь отрисовываем сострояние вне игры
            String str = "Game Over"; // создаем строку "Игра окончена"
            Font f = new Font("Arial",14,Font.BOLD); // создаем шрифт
            g.setColor(Color.white); // цвет для отрисовки
            g.setFont(f); // зададим шрифт только что созданный
            g.drawString(str,125,SIZE/2); // отрисовываем строку
        }
    }

    // (_34_) Все молодцы! Можно играть в Змейку

    public void move(){ // (_21_) сами создаем метод мув. Здесь будет происходить логическая перерисовка точек,
        // т.е. будут передвигаться в том массиве x и y, который мы задали для хранения позиции ячеек
        for (int i = dots; i > 0; i--) { // прописываем цикл for со следующими параметрами,
            x[i] = x[i-1];
            y[i] = y[i-1];
            // таким образом мы сдвигаем так что 2-ая точка становиться на позицию 3-ей, 4-ая на позицию 5-ой,
            // таким образом происходит движение
            // то есть все точки, которые не голова змейки  мы переместили на предыдущие позиции
        }
        // а для головы змейки мы их переместим туда, куда указывает направлние змейки
        if(left){  // если лево, то перемещаем туда. то же самое для каждого направления
            x[0] -= DOT_SIZE;
        }
        if(right){
            x[0] += DOT_SIZE;
        } if(up){
            y[0] -= DOT_SIZE;
        } if(down){
            y[0] += DOT_SIZE;
        }
    }
    // это все, что нужно сделать по движению.
    // затем нужно переоверайдить, переопределить метод paintComponent, который
    // отрисовывает наше игровое поле.
    // вызываем выше метод оверайд (_22_)

    public void checkApple(){ // (_26_)
        if(x[0] == appleX && y[0] == appleY){
            // если голова змейки(x[0]) равно appleX и при этом(&&) y[0] равно appleY,
            dots++; // тогда делается
            createApple(); // создается новое яблоко с помощью метода
        }
    }

    public void checkCollisions(){ // (_28_) прежде всего нужно проверить не столкнулась ли змейка сама с собой
        // это возможно только в том случае, если размер змейки больше 4-х ячеек
        for (int i = dots; i >0 ; i--) { // с помощью цикла for int инициализируем начальные значения дотс
            if(i>4 && x[0] == x[i] && y[0] == y[i]){ // если i текущая ячейка больше 4-х
                // и при этом x[0] равно x[i] и еще при этом y[0] равно y[i]),
                inGame = false; // то значит, что проиграла, столкнулась сама с собой
            }
        }
        // также нужно посмотреть не вышли ли мы за пределы игрового поля

        if(x[0]>SIZE){
            inGame = false;
        }
        if(x[0]<0){
            inGame = false;
        }
        if(y[0]>SIZE){
            inGame = false;
        }
        if(y[0]<0){
            inGame = false;
        }
    }
    // далее создаем обработку нажатия клавиш (_29_)

    @Override
    public void actionPerformed(ActionEvent e) { // (_18_) появился тот самый метод,
        // который будет обрабатываться, вызываться каждый раз когда будет тикать таймер каждые 250 милисекунд
        // далее прписываем, что будет в нем происходить
        if(inGame){ // если мы в игре, то
            checkApple(); // (_25_) прописываем этот метод и сами его создаем
            checkCollisions(); // (_27_) создаем метод, который проверяет
            // не задели ли мы границы при каждом тике таймера. Его создаем сами
            move(); // (_20_) добавляем метод мув, чтобы двигать змейку

        }
        repaint(); // (_19_) метод, который позволяет перерисовывать поле. Метод который вызывает метод PaintComponent
    }

    class FieldKeyListener extends KeyAdapter{ // (_29_) создаем класс внутри класса Game,
        // который будет расширять класс KeyAdapter
        // далее будет оверрайдить, т.е. переопределять метод нажатия
        // нажимаем правую кнопку мыши, выбираем Generate, выбираем Override Method, находим keyPressed
        @Override
        public void keyPressed(KeyEvent e) {
            super.keyPressed(e);
            int key = e.getKeyCode(); // (_30_) смотрим что было нажато, пишем e.getKeyCode,
            // т.е. та клавиша, которая была нажата
            // в соответствии с тем, какая клавиша была нажата будут происходить изменение направления
            if(key == KeyEvent.VK_LEFT && !right){
                // если была нажата клавиша влево и при этом змейка не двигается вправо, то
                left = true;
                up = false;
                down = false;
            }
            // копируем и вставляем еще 3 раза. Меняем значения переменных для остальных ситуцаций
            if(key == KeyEvent.VK_RIGHT && !left){
                right = true;
                up = false;
                down = false;
            }

            if(key == KeyEvent.VK_UP && !down){
                right = false;
                up = true;
                left = false;
            }
            if(key == KeyEvent.VK_DOWN && !up){
                right = false;
                down = true;
                left = false;
            }
        }
    }
    // это все, далее добавляем обрабочтик в игру, т.е. в тело public Game (_31_)


}
